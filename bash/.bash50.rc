#!/usr/bin/env bash
# SPDX-FileCopyrightText: 2021 Uwe Jugel
# SPDX-License-Identifier: MIT

# Bash50: 50 lines of pure Bash for safer scripts and better logs!

# Usage:
# A) Copy and paste these functions, options, and traps to your shell script.
# B) Copy this file and `source` it in your shell script.

# First, we need some nifty little helpers for having nice logs error messages.
ts()   { date --iso-8601=minutes; }
err()  { echo "$(ts): [ERROR] $*" 1>&2; }
log()  { echo "$(ts): [INFO] $*"  1>&2; }
fail() { err "$*: code=$? at $_cm3"; exit 1; }

# Second, let's make sure our shell script super safe and fail fast; just like `make`.
set -o functrace  # trace debug info in funcs and subshells
set -o errtrace   # trace errors in funcs and subshells
set -o pipefail   # consider any error in a pipe
set -o errexit    # exit on any error

# Third, enable debug traces when using `script || fail "message"` statements and
# also setup an ERR trap with a generic message to provide consistent tracing output.
# Tracing is done by a DEBUG trap that "traces" Bash's $BASH_COMMAND and $LINENO.
trap '_cm3="$_cm2" _cm2="$_cm1" _cm1="$_cm0" _cm0="\`$BASH_COMMAND\` in $0:$LINENO"' DEBUG
trap 'fail "command failed"' ERR

# That's all we need! Our Bash script is now safe and has nice error handling and logs.

# Bonus: Allow setting vars from vars, without using unsafe `eval`.
# Usage: `var "$name=$value"` (supports "=" inside the value)
var() {
    local lhs=$(echo "$1" | cut -d"=" -f 1)
    local rhs=$(echo "$1" | cut -d"=" -f 2-)
    test -n "$lhs" || fail "variable name not set for '$1'"
    export "$lhs"="$rhs" # use export to set var by $varname
    log "setting variable $lhs='$rhs'"
}

# STOP: If this file gets longer than 50 lines of code, incl. comments and whitespace,
#       then it is no longer a "script"! Use a real programming language or build system.
