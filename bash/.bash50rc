#!/usr/bin/env bash
# Bash50: 50 lines of pure Bash for safer scripts and better logs!
# Author:  Uwe Jugel, @ubunatic
# License: MIT
# Website: https://github.com/ubunatic/scripts/bash
# Usage:
#   A) Copy and paste these functions, options, and traps to your shell script.
#   B) Copy this file and `source` it in your shell script.

# First, we need some nifty little helpers for having nice logs error messages.
dt()    { date +"%Y-%m-%d %H:%M:%S"; }
err()   { echo "$(dt): [ERROR] $*" 1>&2; }
log()   { echo "$(dt): [INFO] $*"  1>&2; }
fail()  { err "$*, code=$? at $_bash50_trace"; exit 1; }
trace() { if test "$1" = "0"; then _bash50_trace="\`$2\` in $0:$3"; fi; }

# Second, let's make our shell script a bit safer by failing fast; just like `make`.
set -o errexit    # exit on any error in the script (does NOT work inside functions!)
set -o pipefail   # consider errors from failed subcommands of a pipe
set -o functrace  # enabled debug info in funcs and subshells
set -o errtrace   # enable error tracing in funcs and subshells

# Third, enable debug traces when using `script || fail "message"` statements and
# also setup an ERR trap with a generic message to provide consistent tracing output.
# Tracing is done by a DEBUG trap that "traces" Bash's $BASH_COMMAND and $LINENO.
trap 'fail "command failed"' ERR
trap 'trace "$?" "$BASH_COMMAND" "$LINENO" "$FUNCNAME"' DEBUG

# That's all we need! Our Bash script is now a bit safer and has nice error logs.

# Bonus: Allow setting vars from vars, without using unsafe `eval`.
# Usage: `var "$name=$value"` (supports "=" inside the value)
var() {
    local lhs=$(echo "$1" | cut -d"=" -f 1) rhs=$(echo "$1" | cut -d"=" -f 2-)
    test -n "$lhs" || fail "variable name not set for '$1'"
    export "$lhs"="$rhs" # use export to set var by $varname
    log "setting variable $lhs='$rhs'"
}

# STOP: If this file gets longer than 50 lines of code, incl. comments and whitespace,
#       then it is no longer a "script"! Use a real programming language or build system.
